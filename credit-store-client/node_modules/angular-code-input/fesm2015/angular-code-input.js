import { __awaiter } from 'tslib';
import { InjectionToken, EventEmitter, Component, Optional, Inject, ViewChildren, Input, Output, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/code-input.component.config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CodeInputComponentConfigToken = new InjectionToken('CodeInputComponentConfig');
/**
 * @record
 */
function CodeInputComponentConfig() { }
if (false) {
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.codeLength;
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.inputType;
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.initialFocusField;
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.isCharsCode;
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.isCodeHidden;
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.isPrevFocusableAfterClearing;
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.isFocusingOnLastByClickIfFilled;
    /** @type {?|undefined} */
    CodeInputComponentConfig.prototype.code;
}
/** @type {?} */
const defaultComponentConfig = {
    codeLength: 4,
    inputType: 'tel',
    initialFocusField: undefined,
    isCharsCode: false,
    isCodeHidden: false,
    isPrevFocusableAfterClearing: true,
    isFocusingOnLastByClickIfFilled: false,
    code: undefined
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/code-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const InputState = {
    ready: 0,
    reset: 1,
};
InputState[InputState.ready] = 'ready';
InputState[InputState.reset] = 'reset';
class CodeInputComponent {
    /**
     * @param {?=} config
     */
    constructor(config) {
        /**
         * @deprecated Use isCharsCode prop instead.
         */
        this.isNonDigitsCode = false;
        this.codeChanged = new EventEmitter();
        this.codeCompleted = new EventEmitter();
        this.inputs = [];
        this.inputsStates = [];
        this.state = {
            isFocusingAfterAppearingCompleted: false,
            isInitialFocusFieldEnabled: false
        };
        Object.assign(this, defaultComponentConfig);
        if (!config) {
            return;
        }
        // filtering for only valid config props
        for (const prop in config) {
            if (!config.hasOwnProperty(prop)) {
                continue;
            }
            if (!defaultComponentConfig.hasOwnProperty(prop)) {
                continue;
            }
            // @ts-ignore
            this[prop] = config[prop];
        }
    }
    /**
     * Life cycle
     * @return {?}
     */
    ngOnInit() {
        // defining internal code length prop for skipping external prop updates
        this._codeLength = this.codeLength;
        this.placeholders = Array(this._codeLength).fill(1);
        this.state.isInitialFocusFieldEnabled = !this.isEmpty(this.initialFocusField);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.inputsList.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            this.inputs.push(item.nativeElement);
            this.inputsStates.push(InputState.ready);
        }));
        // the @Input code might have value. Checking
        this.onInputCodeChanges();
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.focusOnInputAfterAppearing();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.code) {
            this.onInputCodeChanges();
        }
    }
    /**
     * Methods
     * @param {?=} isChangesEmitting
     * @return {?}
     */
    reset(isChangesEmitting = false) {
        // resetting the code to its initial value or to an empty value
        this.onInputCodeChanges();
        if (this.state.isInitialFocusFieldEnabled) {
            // tslint:disable-next-line:no-non-null-assertion
            this.focusOnField((/** @type {?} */ (this.initialFocusField)));
        }
        if (isChangesEmitting) {
            this.emitChanges();
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    focusOnField(index) {
        if (index >= this._codeLength) {
            throw new Error('The index of the focusing input box should be less than the codeLength.');
        }
        this.inputs[index].focus();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        // handle click events only if the the prop is enabled
        if (!this.isFocusingOnLastByClickIfFilled) {
            return;
        }
        /** @type {?} */
        const target = e.target;
        /** @type {?} */
        const last = this.inputs[this._codeLength - 1];
        // already focused
        if (target === last) {
            return;
        }
        // check filling
        /** @type {?} */
        const isFilled = this.getCurrentFilledCode().length >= this._codeLength;
        if (!isFilled) {
            return;
        }
        // focusing on the last input if is filled
        setTimeout((/**
         * @return {?}
         */
        () => last.focus()));
    }
    /**
     * @param {?} e
     * @param {?} i
     * @return {?}
     */
    onInput(e, i) {
        /** @type {?} */
        const target = e.target;
        /** @type {?} */
        const value = e.data || target.value;
        if (this.isEmpty(value)) {
            return;
        }
        // only digits are allowed if isCharsCode flag is absent/false
        if (!this.canInputValue(value)) {
            e.preventDefault();
            e.stopPropagation();
            this.setInputValue(target, null);
            this.setStateForInput(target, InputState.reset);
            return;
        }
        /** @type {?} */
        const values = value.toString().trim().split('');
        for (let j = 0; j < values.length; j++) {
            /** @type {?} */
            const index = j + i;
            if (index > this._codeLength - 1) {
                break;
            }
            this.setInputValue(this.inputs[index], values[j]);
        }
        this.emitChanges();
        /** @type {?} */
        const next = i + values.length;
        if (next > this._codeLength - 1) {
            target.blur();
            return;
        }
        this.inputs[next].focus();
    }
    /**
     * @param {?} e
     * @param {?} i
     * @return {?}
     */
    onPaste(e, i) {
        e.preventDefault();
        e.stopPropagation();
        /** @type {?} */
        const data = e.clipboardData ? e.clipboardData.getData('text').trim() : undefined;
        if (this.isEmpty(data)) {
            return;
        }
        // Convert paste text into iterable
        // tslint:disable-next-line:no-non-null-assertion
        /** @type {?} */
        const values = (/** @type {?} */ (data)).split('');
        /** @type {?} */
        let valIndex = 0;
        for (let j = i; j < this.inputs.length; j++) {
            // The values end is reached. Loop exit
            if (valIndex === values.length) {
                break;
            }
            /** @type {?} */
            const input = this.inputs[j];
            /** @type {?} */
            const val = values[valIndex];
            // Cancel the loop when a value cannot be used
            if (!this.canInputValue(val)) {
                this.setInputValue(input, null);
                this.setStateForInput(input, InputState.reset);
                return;
            }
            this.setInputValue(input, val.toString());
            valIndex++;
        }
        this.inputs[i].blur();
        this.emitChanges();
    }
    /**
     * @param {?} e
     * @param {?} i
     * @return {?}
     */
    onKeydown(e, i) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const target = e.target;
            /** @type {?} */
            const isTargetEmpty = this.isEmpty(target.value);
            /** @type {?} */
            const prev = i - 1;
            // processing only backspace events
            /** @type {?} */
            const isBackspaceKey = yield this.isBackspaceKey(e);
            if (!isBackspaceKey) {
                return;
            }
            e.preventDefault();
            this.setInputValue(target, null);
            if (!isTargetEmpty) {
                this.emitChanges();
            }
            if (prev < 0) {
                return;
            }
            if (isTargetEmpty || this.isPrevFocusableAfterClearing) {
                this.inputs[prev].focus();
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    onInputCodeChanges() {
        if (!this.inputs.length) {
            return;
        }
        if (this.isEmpty(this.code)) {
            this.inputs.forEach((/**
             * @param {?} input
             * @return {?}
             */
            (input) => {
                this.setInputValue(input, null);
            }));
            return;
        }
        // tslint:disable-next-line:no-non-null-assertion
        /** @type {?} */
        const chars = (/** @type {?} */ (this.code)).toString().trim().split('');
        // checking if all the values are correct
        /** @type {?} */
        let isAllCharsAreAllowed = true;
        for (const char of chars) {
            if (!this.canInputValue(char)) {
                isAllCharsAreAllowed = false;
                break;
            }
        }
        this.inputs.forEach((/**
         * @param {?} input
         * @param {?} index
         * @return {?}
         */
        (input, index) => {
            /** @type {?} */
            const value = isAllCharsAreAllowed ? chars[index] : null;
            this.setInputValue(input, value);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    focusOnInputAfterAppearing() {
        if (!this.state.isInitialFocusFieldEnabled) {
            return;
        }
        if (this.state.isFocusingAfterAppearingCompleted) {
            return;
        }
        // tslint:disable-next-line:no-non-null-assertion
        this.focusOnField((/** @type {?} */ (this.initialFocusField)));
        // tslint:disable-next-line:no-non-null-assertion
        this.state.isFocusingAfterAppearingCompleted = document.activeElement === this.inputs[(/** @type {?} */ (this.initialFocusField))];
    }
    /**
     * @private
     * @return {?}
     */
    emitChanges() {
        setTimeout((/**
         * @return {?}
         */
        () => this.emitCode()), 50);
    }
    /**
     * @private
     * @return {?}
     */
    emitCode() {
        /** @type {?} */
        const code = this.getCurrentFilledCode();
        this.codeChanged.emit(code);
        if (code.length >= this._codeLength) {
            this.codeCompleted.emit(code);
        }
    }
    /**
     * @private
     * @return {?}
     */
    getCurrentFilledCode() {
        /** @type {?} */
        let code = '';
        for (const input of this.inputs) {
            if (!this.isEmpty(input.value)) {
                code += input.value;
            }
        }
        return code;
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    isBackspaceKey(e) {
        /** @type {?} */
        const isBackspace = (e.key && e.key.toLowerCase() === 'backspace') || (e.keyCode && e.keyCode === 8);
        if (isBackspace) {
            return Promise.resolve(true);
        }
        // process only key with placeholder keycode on android devices
        if (!e.keyCode || e.keyCode !== 229) {
            return Promise.resolve(false);
        }
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            setTimeout((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const input = e.target;
                /** @type {?} */
                const isReset = this.getStateForInput(input) === InputState.reset;
                if (isReset) {
                    this.setStateForInput(input, InputState.ready);
                }
                // if backspace key pressed the caret will have position 0 (for single value field)
                resolve(input.selectionStart === 0 && !isReset);
            }));
        }));
    }
    /**
     * @private
     * @param {?} input
     * @param {?} value
     * @return {?}
     */
    setInputValue(input, value) {
        /** @type {?} */
        const isEmpty = this.isEmpty(value);
        /** @type {?} */
        const valueClassCSS = 'has-value';
        /** @type {?} */
        const emptyClassCSS = 'empty';
        if (isEmpty) {
            input.value = '';
            input.classList.remove(valueClassCSS);
            // tslint:disable-next-line:no-non-null-assertion
            (/** @type {?} */ (input.parentElement)).classList.add(emptyClassCSS);
        }
        else {
            input.value = value;
            input.classList.add(valueClassCSS);
            // tslint:disable-next-line:no-non-null-assertion
            (/** @type {?} */ (input.parentElement)).classList.remove(emptyClassCSS);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    canInputValue(value) {
        if (this.isEmpty(value)) {
            return false;
        }
        /** @type {?} */
        const isDigitsValue = /^[0-9]+$/.test(value.toString());
        return isDigitsValue || (this.isCharsCode || this.isNonDigitsCode);
    }
    /**
     * @private
     * @param {?} input
     * @param {?} state
     * @return {?}
     */
    setStateForInput(input, state) {
        /** @type {?} */
        const index = this.inputs.indexOf(input);
        if (index < 0) {
            return;
        }
        this.inputsStates[index] = state;
    }
    /**
     * @private
     * @param {?} input
     * @return {?}
     */
    getStateForInput(input) {
        /** @type {?} */
        const index = this.inputs.indexOf(input);
        return this.inputsStates[index];
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isEmpty(value) {
        return value === null || value === undefined || !value.toString().length;
    }
}
CodeInputComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'code-input',
                template: "<span *ngFor=\"let holder of placeholders; index as i\"\n      [class.code-hidden]=\"isCodeHidden\">\n  <input #input\n         (click)=\"onClick($event)\"\n         (paste)=\"onPaste($event, i)\"\n         (input)=\"onInput($event, i)\"\n         (keydown)=\"onKeydown($event, i)\"\n         [type]=\"inputType\"/>\n</span>\n",
                styles: [":host{--color:#171516;--item-background:transparent;--item-border:1px solid #ddd;--item-border-bottom:1px solid #ddd;--item-border-bottom-focused:1px solid #ddd;--item-border-bottom-has-value:1px solid #ddd;--item-border-focused:1px solid #ddd;--item-border-has-value:1px solid #ddd;--item-border-radius:5px;--item-height:4.375em;--item-shadow-focused:0px 1px 5px #ddd;--item-spacing:4px;--text-security-type:disc;color:var(--color);display:flex;font-size:inherit;transform:translateZ(0)}:host span{display:block;flex:1;padding-right:var(--item-spacing)}:host span:first-child{padding-left:var(--item-spacing)}:host span.code-hidden input{-moz-text-security:var(--text-security-type);-webkit-text-security:var(--text-security-type);text-security:var(--text-security-type)}:host input{-webkit-appearance:none;-webkit-transform:translateZ(0);background:var(--item-background);border:var(--item-border);border-bottom:var(--item-border-bottom);border-radius:var(--item-border-radius);color:inherit;font-size:inherit;height:var(--item-height);outline:none;text-align:center;transform:translateZ(0);width:100%}:host input.has-value{border:var(--item-border-has-value);border-bottom:var(--item-border-bottom-has-value)}:host input:focus{border:var(--item-border-focused);border-bottom:var(--item-border-bottom-focused);box-shadow:var(--item-shadow-focused)}"]
            }] }
];
/** @nocollapse */
CodeInputComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CodeInputComponentConfigToken,] }] }
];
CodeInputComponent.propDecorators = {
    inputsList: [{ type: ViewChildren, args: ['input',] }],
    codeLength: [{ type: Input }],
    inputType: [{ type: Input }],
    initialFocusField: [{ type: Input }],
    isNonDigitsCode: [{ type: Input }],
    isCharsCode: [{ type: Input }],
    isCodeHidden: [{ type: Input }],
    isPrevFocusableAfterClearing: [{ type: Input }],
    isFocusingOnLastByClickIfFilled: [{ type: Input }],
    code: [{ type: Input }],
    codeChanged: [{ type: Output }],
    codeCompleted: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    CodeInputComponent.prototype.inputsList;
    /** @type {?} */
    CodeInputComponent.prototype.codeLength;
    /** @type {?} */
    CodeInputComponent.prototype.inputType;
    /** @type {?} */
    CodeInputComponent.prototype.initialFocusField;
    /**
     * @deprecated Use isCharsCode prop instead.
     * @type {?}
     */
    CodeInputComponent.prototype.isNonDigitsCode;
    /** @type {?} */
    CodeInputComponent.prototype.isCharsCode;
    /** @type {?} */
    CodeInputComponent.prototype.isCodeHidden;
    /** @type {?} */
    CodeInputComponent.prototype.isPrevFocusableAfterClearing;
    /** @type {?} */
    CodeInputComponent.prototype.isFocusingOnLastByClickIfFilled;
    /** @type {?} */
    CodeInputComponent.prototype.code;
    /** @type {?} */
    CodeInputComponent.prototype.codeChanged;
    /** @type {?} */
    CodeInputComponent.prototype.codeCompleted;
    /** @type {?} */
    CodeInputComponent.prototype.placeholders;
    /**
     * @type {?}
     * @private
     */
    CodeInputComponent.prototype.inputs;
    /**
     * @type {?}
     * @private
     */
    CodeInputComponent.prototype.inputsStates;
    /**
     * @type {?}
     * @private
     */
    CodeInputComponent.prototype._codeLength;
    /**
     * @type {?}
     * @private
     */
    CodeInputComponent.prototype.state;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/code-input.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CodeInputModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: CodeInputModule,
            providers: [
                { provide: CodeInputComponentConfigToken, useValue: config }
            ]
        };
    }
}
CodeInputModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    CodeInputComponent
                ],
                exports: [
                    CodeInputComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: angular-code-input.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CodeInputComponent, CodeInputModule, CodeInputComponentConfigToken as ɵa };
//# sourceMappingURL=angular-code-input.js.map
