import { EventEmitter, Component, ChangeDetectionStrategy, Input, Output, ViewChildren, HostListener, Directive, NgModule } from '@angular/core';
import { FormArray, FormControl, Validators, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

class NgxOtpInputComponent {
    constructor() {
        this.ngxOtpArray = new FormArray([]);
        this.focusedInputHasValue = false;
        this.lastFocus = 0;
        this.defaultAriaLabel = 'One time password input';
        this.ariaLabels = [];
        this.classList = [];
        this.otpChange = new EventEmitter();
        this.fill = new EventEmitter();
    }
    get ngxOtpArrayControls() {
        return this.ngxOtpArray.controls;
    }
    set status(status) {
        this.ngxOtpStatus = status;
        this.setInputClasses();
    }
    set disable(isDisabled) {
        this.isDisabled = isDisabled;
        this.handleDisable(isDisabled);
    }
    onPaste(event) {
        event.preventDefault();
        this.setValue(event.clipboardData.getData('text'));
    }
    ngOnInit() {
        this.setUpOtpForm();
        this.setUpAriaLabels();
        this.setInputClasses();
        this.otpFormChangeListener();
        if (this.config.autoblur === undefined) {
            this.config.autoblur = true;
        }
    }
    ngAfterViewInit() {
        if (this.config.numericInputMode || !this.config.pattern) {
            this.otpInputElements.map((element) => {
                element.nativeElement.setAttribute('inputmode', 'numeric');
                element.nativeElement.setAttribute('pattern', '[0-9]*');
            });
        }
        if (this.config.autofocus) {
            this.setFocus(0);
        }
    }
    ngOnDestroy() {
        this.ngxOtpArray$.unsubscribe();
    }
    getAriaLabelByIndex(index) {
        return this.ariaLabels[index]
            ? this.ariaLabels[index]
            : this.defaultAriaLabel;
    }
    handleFocus(index) {
        this.lastFocus = index;
        this.getInputElementByIndex(index).select();
    }
    handleKeyup(value, index) {
        if (this.pattern.test(value) && value !== 'Backspace') {
            this.getFormControlByIndex(index).setValue(value); // prevent fast type errors
            this.stepForward(index);
        }
        else if (value === 'Backspace') {
            this.stepBackward(index);
        }
        this.setInputClasses();
    }
    handleKeydown(index) {
        this.focusedInputHasValue = !!this.getFormControlByIndex(index).value;
    }
    handleLeftArrow(index) {
        if (index > 0) {
            this.setFocus(index - 1);
        }
    }
    handleRightArrow(index) {
        if (index < this.config.otpLength - 1) {
            this.setFocus(index + 1);
        }
    }
    clear() {
        this.ngxOtpArray.reset();
        this.setInputClasses();
    }
    setUpOtpForm() {
        for (let i = 0; i < this.config.otpLength; i++) {
            this.ngxOtpArray.push(new FormControl(null, [Validators.required]));
        }
        this.pattern = this.config.pattern || /^\d+$/;
    }
    setUpAriaLabels() {
        if (this.config.ariaLabels) {
            Array.isArray(this.config.ariaLabels)
                ? (this.ariaLabels = this.config.ariaLabels)
                : (this.ariaLabels = new Array(this.config.otpLength).fill(this.config.ariaLabels));
        }
    }
    setInputClasses() {
        var _a, _b;
        const inputEntry = [];
        const classList = this.config.classList;
        for (let i = 0; i < this.config.otpLength; i++) {
            const isFilled = this.isInputFilled(i)
                ? ((_a = this.config.classList) === null || _a === void 0 ? void 0 : _a.inputFilled) || ''
                : '';
            const isDisabled = this.isDisabled
                ? ((_b = this.config.classList) === null || _b === void 0 ? void 0 : _b.inputDisabled) || 'ngx-otp-input-disabled'
                : '';
            let status = '';
            if (this.ngxOtpStatus === 'success') {
                status = this.config.classList.inputSuccess;
            }
            else if (this.ngxOtpStatus === 'error') {
                status = this.config.classList.inputError;
            }
            inputEntry[i] = [(classList === null || classList === void 0 ? void 0 : classList.input) || '', isFilled, isDisabled, status];
        }
        this.classList = inputEntry;
    }
    setValue(value) {
        if (this.pattern.test(value)) {
            let lastIndex = 0;
            value
                .split('')
                .slice(0, this.config.otpLength)
                .map((character, index) => {
                this.getFormControlByIndex(index).setValue(character);
                lastIndex = index;
            });
            this.setInputClasses();
            this.setFocusAfterValueSet(lastIndex);
        }
    }
    handleDisable(disable) {
        var _a, _b;
        disable ? (_a = this.ngxOtpArray) === null || _a === void 0 ? void 0 : _a.disable() : (_b = this.ngxOtpArray) === null || _b === void 0 ? void 0 : _b.enable();
        this.setInputClasses();
    }
    stepForward(index) {
        if (this.ngxOtpArray.valid && this.config.autoblur) {
            this.removeFocus(index);
        }
        else if (index < this.config.otpLength - 1) {
            this.setFocus(index + 1);
        }
    }
    stepBackward(index) {
        if (!this.focusedInputHasValue && index > 0) {
            this.setFocus(index - 1);
        }
    }
    setFocusAfterValueSet(lastIndex) {
        if (lastIndex < this.config.otpLength - 1) {
            this.setFocus(lastIndex + 1);
        }
        else {
            this.removeFocus(this.lastFocus);
        }
    }
    setFocus(index) {
        this.getInputElementByIndex(index).focus();
    }
    removeFocus(index) {
        this.getInputElementByIndex(index).blur();
    }
    isInputFilled(index) {
        var _a;
        return (_a = this.getFormControlByIndex(index)) === null || _a === void 0 ? void 0 : _a.valid;
    }
    getInputElementByIndex(index) {
        return this.otpInputElements.toArray()[index].nativeElement;
    }
    getFormControlByIndex(index) {
        return this.ngxOtpArray.controls[index];
    }
    otpFormChangeListener() {
        this.ngxOtpArray$ = this.ngxOtpArray.valueChanges.subscribe((values) => {
            this.otpChange.emit(values);
            if (this.ngxOtpArray.valid) {
                this.fill.emit(values.join(''));
            }
        });
    }
}
NgxOtpInputComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'ngx-otp-input',
                template: "<form [ngClass]=\"config.classList?.container\" class=\"ngx-otp-input-container\">\n  <div\n    *ngFor=\"let control of ngxOtpArrayControls; let i = index\"\n    [ngClass]=\"config.classList?.inputBox\"\n    class=\"ngx-otp-input-box\"\n  >\n    <label [attr.aria-label]=\"getAriaLabelByIndex(i)\">\n      <input\n        #otpInputElement\n        [id]=\"'ngx-otp-input-' + i\"\n        [formControl]=\"control\"\n        [ngxOtpPattern]=\"pattern\"\n        [type]=\"config.isPasswordInput ? 'password' : 'text'\"\n        [ngClass]=\"classList[i]\"\n        (focus)=\"handleFocus(i)\"\n        (keyup)=\"handleKeyup($event.key, i)\"\n        (keyup.arrowLeft)=\"handleLeftArrow(i)\"\n        (keyup.arrowRight)=\"handleRightArrow(i)\"\n        (keydown.backspace)=\"handleKeydown(i)\"\n        class=\"ngx-otp-input\"\n        maxlength=\"1\"\n        autocomplete=\"off\"\n        autocapitalize=\"off\"\n        spellcheck=\"false\"\n      />\n    </label>\n  </div>\n</form>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-otp-input-container{display:flex}.ngx-otp-input-box{margin:0 5px}.ngx-otp-input-box:first-child{margin-left:0}.ngx-otp-input-box:last-child{margin-right:0}.ngx-otp-input{width:35px;height:35px;text-align:center;font-size:1.25rem;border:1px solid #212121;border-radius:4px;outline:0}.ngx-otp-input-disabled{opacity:.3}"]
            },] }
];
NgxOtpInputComponent.ctorParameters = () => [];
NgxOtpInputComponent.propDecorators = {
    config: [{ type: Input }],
    status: [{ type: Input }],
    disable: [{ type: Input }],
    otpChange: [{ type: Output }],
    fill: [{ type: Output }],
    otpInputElements: [{ type: ViewChildren, args: ['otpInputElement',] }],
    onPaste: [{ type: HostListener, args: ['paste', ['$event'],] }]
};

class PatternDirective {
    constructor() {
        // allowed keys apart from numeric characters
        this.allowedKeys = [
            'Backspace',
            'ArrowLeft',
            'ArrowRight',
            'Escape',
            'Tab',
        ];
    }
    onKeyDown(e) {
        if (this.allowedKeys.includes(e.key) ||
            (e.key === 'a' && e.ctrlKey === true) || // Allow: Ctrl+A
            (e.key === 'c' && e.ctrlKey === true) || // Allow: Ctrl+C
            (e.key === 'v' && e.ctrlKey === true) || // Allow: Ctrl+V
            (e.key === 'x' && e.ctrlKey === true) || // Allow: Ctrl+X
            (e.key === 'a' && e.metaKey === true) || // Cmd+A (Mac)
            (e.key === 'c' && e.metaKey === true) || // Cmd+C (Mac)
            (e.key === 'v' && e.metaKey === true) || // Cmd+V (Mac)
            (e.key === 'x' && e.metaKey === true) // Cmd+X (Mac)
        ) {
            return; // let it happen, don't do anything
        }
        else if (!this.pattern.test(e.key)) {
            e.preventDefault();
        }
    }
}
PatternDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[ngxOtpPattern]',
            },] }
];
PatternDirective.propDecorators = {
    pattern: [{ type: Input, args: ['ngxOtpPattern',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

class NgxOtpInputModule {
}
NgxOtpInputModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxOtpInputComponent, PatternDirective],
                imports: [ReactiveFormsModule, FormsModule, CommonModule],
                exports: [NgxOtpInputComponent],
            },] }
];

/*
 * Public API Surface of ngx-otp-input
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxOtpInputComponent, NgxOtpInputModule, PatternDirective as ɵa };
//# sourceMappingURL=ngx-otp-input.js.map
